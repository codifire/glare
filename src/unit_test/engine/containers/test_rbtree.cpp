#include "test_containers.h"
#include "containers/RbTree.h"
#include "gtest/gtest.h"
#include <string>
#include <vector>
#include <set>
#include <stdlib.h>


namespace glare { namespace
{
    enum    fake_rbtree_type { fake_rbtree_val0, fake_rbtree_val1 };
    typedef fake_rbtree_type                            FakeType;
    typedef TestObject<FakeType, TestObjectInfoType>    TestObjectType;

    typedef int                                         test_key_t;
    typedef TestObjectType                              test_val_t;
    typedef default_allocator<test_val_t>               test_allocator_t;
    typedef RedBlackTree<test_key_t, test_val_t>        rbtree_t;
    typedef RbTreeNode<test_key_t, test_val_t>          rbtree_node_t;

    typedef rbtree_t::iterator                          rb_iterator;
    typedef rbtree_t::const_iterator                    rb_const_iterator;
    typedef rbtree_t::reverse_iterator                  rb_reverse_iterator;
    typedef rbtree_t::const_reverse_iterator            rb_const_reverse_iterator;

    typedef GLARE_PAIR<rb_iterator, bool>               rb_insert_result_t;
    typedef GLARE_PAIR<test_key_t, test_val_t>          rb_pair;

    TestObjectType::state_type::state_object_type& refStateInfo = TestObjectType::getState().getStateInfo();

    test_key_t inputArr[] = { 600, 756, 650, 500, 530, 610, 640, 620, 630, 700, 850, 770, 950, 730, 720, 710, 100, 520, 210, 525, 521, 515 };

    rbtree_t rbTree;
    

    TEST(Rbtree_Node_Test, test_check_construction)
    {
        using namespace glare;

        std::pair<int, int> p(1, 11);
        RbTreeNode<int, int> node1(p);

        EXPECT_EQ(nullptr, node1.left()) << "Node left must be nullptr";
        EXPECT_EQ(nullptr, node1.right()) << "Node right must be nullptr";
        EXPECT_EQ(nullptr, node1.parent()) << "Node parent must be nullptr";
        EXPECT_TRUE(node1.isRed()) << "Newly created node must be red, unless copy-constructed";

        node1.color(RbTreeNode<int, int>::Black);

        RbTreeNode<int, int> node2(node1);
        
        // RbTreeNode<int, int> node3;
        // node3 = node1; // We never assign nodes, we only change links, shouldn't compile!

        EXPECT_EQ(nullptr, node2.left()) << "Node left must be nullptr, even if copy constructed";
        EXPECT_EQ(nullptr, node2.right()) << "Node right must be nullptr, even if copy constructed";
        EXPECT_EQ(nullptr, node2.parent()) << "Node parent must be nullptr, even if copy constructed";
        EXPECT_EQ(node1.color(), node2.color()) << "Copy constructed node should have the same color";
        EXPECT_EQ(node1.key(), node2.key()) << "Copy constructed node should have the same key";
        EXPECT_EQ(node1.value(), node2.value()) << "Copy constructed node should have the same value";
    };

    TEST(RedBlackTree_Test, test_check_default_construction)
    {
        EXPECT_TRUE(rbTree.empty() ) << "Should be empty";
        EXPECT_EQ(0, rbTree.size()) << "Size must be 0";
    };

    TEST(RedBlackTree_Test, test_check_insertion)
    {
        {   // To limit objects lifetime.
            rb_pair item;    // 1 default constructor call for the test_val_t
            rbtree_t rbtree;
            const size_t SIZE = sizeof(inputArr) / sizeof(test_key_t);

            // Put all the input vales in the tree!
            for (size_t i=0; i<SIZE; ++i)
            {
                item.first = inputArr[i];
                rbtree.insert(item); // Each call will copy-construct a test_val_t object, no temporaries.
            }

            EXPECT_EQ(refStateInfo.m_copyConstructor_count, SIZE) << "There are temporaries being generated by insert() call, why??";
            EXPECT_EQ(0, refStateInfo.m_destructor_count) << "Who died? Must be a temporary"; // We don't expect a d'tor call yet.

            // No constructor or copy constructor call is expected for the below case:
            item.first = inputArr[0];
            rb_insert_result_t res = rbtree.insert(item);
            EXPECT_FALSE(res.second) << "Can't insert same entry more than once";

            // Just 1 more copy-constructor call is expected for the below case:
            item.first = 990;
            res = rbtree.insert(item);
            EXPECT_TRUE(res.second) << "Can't insert entry, why?";
            EXPECT_EQ(res.first->first, item.first) << "Incorrect iterator being returned";  // Making sure whether the iterator points to the inserted item?

            EXPECT_EQ(refStateInfo.m_copyConstructor_count, SIZE + 1) << "There are temporaries being generated, why??";

            TestObjectType::enableState(false);
            rbTree = rbtree; // We don't want the logs for this operation to be reflected, intentional indeed!
            TestObjectType::enableState(true);

            // But we check for the success of it though.
            EXPECT_EQ(rbTree.size(), rbtree.size()) << "Assignment operation failed";
        }
        // A lot of objects are expected to die afterwards
        // 1 default ctor call for "rb_pair item"
        // SIZE + 1 copy-ctor calls during insertions
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, test_copy_construction_and_assignment_op)
    {
        { // To limit the object lifetime.
            size_t prevStateInfo = refStateInfo.m_copyConstructor_count;
            rbtree_t rbtreeA(rbTree); // This will incur copy-ctor calls == rbTree.size().
            EXPECT_EQ(rbTree.size(), rbtreeA.size()) << "Copy construction failed";

            // Forget about the previous constructor/copy-constructor calls, focus on this one only, for now.
            size_t ctorCalls = refStateInfo.m_copyConstructor_count - prevStateInfo;
            EXPECT_EQ(ctorCalls, rbtreeA.size()) << "Error!, Copy constructor calls must be equal to the no of items in the tree"; // 1 call for each object.

            prevStateInfo = refStateInfo.m_copyConstructor_count;

            {
                rbtree_t rbtreeB;
                rbtreeB = rbtreeA; // The operation to test.

                size_t ctorCalls = refStateInfo.m_copyConstructor_count - prevStateInfo;

                EXPECT_EQ(rbTree.size(), rbtreeB.size()) << "Assignment operation failed";
                EXPECT_EQ(ctorCalls, rbtreeB.size()) << "Error!, Copy constructor calls must be equal to the no of items in the tree"; // 1 call for each object.
            }
        }
        // At this point everything dies that we created. Lets check the validity of object construction/destruction till now.
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, test_erase_and_find)
    {
        {
            rbtree_t rbtree(rbTree);
            test_val_t val; // Default constructed!
            
            rb_iterator itr = rbtree.find(100);
            EXPECT_NE(itr, rbtree.end()) << "This key exists but still not found in the lookup";
            EXPECT_EQ(itr->first, 100) << "Iterator returned is not valid";

            EXPECT_TRUE(rbtree.exists(100)) << "RbTree::exists() This key exists but still not found in the lookup";
            // Below call should cause assignment
            EXPECT_TRUE(rbtree.find(100, val)) << "RbTree::find(k, v) This key exists but still not found in the lookup";

            size_t dtorCalls = refStateInfo.m_destructor_count;
            rbtree.erase(itr);
            EXPECT_EQ(refStateInfo.m_destructor_count, dtorCalls + 1) << "We just erased an object and still no destructor called";

            itr = rbtree.find(100);
            EXPECT_EQ(rbtree.end(), itr) << "This key should not exist anymore 'cos we deleted it";
            
            EXPECT_FALSE(rbtree.exists(100)) << "RbTree::exists() This key should not exist anymore 'cos we deleted it";
            // Below call should not cause any assignment, as we expect false!
            EXPECT_FALSE(rbtree.find(100, val)) << "RbTree::find(k, v) This key should not exist anymore 'cos we deleted it";

            itr = rbtree.begin();
            test_key_t key = itr->first;
            rbtree.erase(itr);
            EXPECT_EQ(rbtree.end(), rbtree.find(key)) << "This key should not exist anymore 'cos we deleted it";

            // Test for specific cases below:
            rbtree.erase(525);
            EXPECT_FALSE(rbtree.exists(525)) << "RbTree::exists() This key should not exist anymore 'cos we deleted it";

            rbtree.insert(525, val);
            rbtree.insert(560, val);
            rbtree.erase(525);
            rbtree.insert(535, val);
            rbtree.erase(600);
            rbtree.insert(550, val);
            rbtree.erase(530);
            rbtree.erase(730);
            rbtree.insert(615, val);
            rbtree.erase(710);
            rbtree.erase(700);
            rbtree.erase(560);
            rbtree.erase(500);
            rbtree.erase(520);
            rbtree.insert(560, val);
            rbtree.insert(570, val);
            rbtree.erase(515);

            const size_t SIZE = sizeof(inputArr) / sizeof(test_key_t);
            for (size_t i = 0; i < SIZE; ++i)
            {
                rb_iterator it = rbtree.find(inputArr[i]);
                if(it != rbtree.end())
                {
                    rbtree.erase(it); // Take it easy, just for testing purpose.
                }
            }

            int count = 0;
            for (size_t i = 0; i < SIZE; ++i)
            {
                if(rbtree.exists(inputArr[i]))
                {
                    count++;
                }
            }

            EXPECT_EQ(0, count) << "None of the keys from the input array should have been found in the tree";

            rbtree_t rbtree1;
            rbtree1.insert(1, val);

            rbtree_t rbtree2;
            rbtree2.insert(1, val);
            rbtree2.insert(2, val);

            rbtree_t rbtree3;
            rbtree3.insert(1, val);
            rbtree3.insert(2, val);
            rbtree3.insert(3, val);

            rbtree1.erase(1);
            rbtree1.erase(2);
            rbtree1.erase(3);
            
            rbtree2.erase(1);
            rbtree2.erase(2);
            rbtree2.erase(3);

            rbtree3.erase(1);
            rbtree3.erase(2);
            rbtree3.erase(3);
        }
        // At this point everything dies that we created. Lets check the validity of object construction/destruction till now.
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, test_iterators)
    {
        {
            int prevValue = 0;
            bool flag = true; // To check the validity of iterator increments;
            int count = 0;

            rbtree_t rbtree(rbTree);
            rb_iterator it = rbtree.begin();
            while (it != rbtree.end())
            {
                if (it->first > prevValue)
                {
                    prevValue = it->first;
                }
                else
                {
                    flag = false;
                }
                ++it;
                ++count;
            }

            EXPECT_TRUE(flag)  << "Since we do inorder traversal on the iterator increment, every current value must be greater than the previous value";
            EXPECT_EQ(count, rbtree.size()) << "No. of iterations == No. of elements in the container";

            flag = true;
            prevValue = 0x7fffFFff;
            count = 0;

            rb_reverse_iterator rit = rbtree.rbegin();
            while (rit != rbtree.rend())
            {
                if (rit->first < prevValue)
                {
                    prevValue = rit->first;
                }
                else
                {
                    flag = false;
                }
                ++rit;
                ++count;
            }

            rb_const_iterator const_it = rbtree.begin();             // Ok!
            rb_const_reverse_iterator const_rit = rbtree.rbegin();   // Ok!

            (void) const_it;
            (void) const_rit;

            // RedBlackTree<int, int>::reverse_iterator err_it = gmap.begin();          // Error, as we desire!
            // RedBlackTree<int, int>::iterator err_rit1 = gmap.rbegin();               // Error, as we desire!
            // RedBlackTree<int, int>::const_reverse_iterator err_rit2 = gmap.begin();  // Error, as we desire!

            EXPECT_TRUE(flag)  << "Since we do inorder traversal from rightmost node, every current value must be less than the previous value";
            EXPECT_EQ(count, rbtree.size()) << "No. of iterations == No. of elements in the container";

            test_val_t val; // Default constructed!
            rbtree_t rbtree2;

            rbtree_t rbtree0;
            EXPECT_EQ(rbtree0.begin(), rbtree0.end()) << "Iterator begin must be equal to end of empty tree";
            EXPECT_EQ(rbtree0.rbegin(), rbtree0.rend()) << "Iterator begin must be equal to end of empty tree";

            rbtree_t rbtree1;
            rbtree1.insert(1, val);
            it = rbtree1.begin();
            rit = rbtree1.rbegin();
            EXPECT_NE(rbtree1.begin(), rbtree1.end()) << "Iterator begin must not be equal to end of tree with 1 node";
            EXPECT_EQ(it->first, rit->first) << "Illegal leftmost or rightmost node of the tree";

            rbtree2.insert(1, val);
            rbtree2.insert(2, val);
            it = rbtree2.begin();
            rit = rbtree2.rbegin();
            
            EXPECT_EQ(1, it->first) << "Illegal leftmost node of the tree";
            EXPECT_EQ(2, rit->first) << "Illegal rightmost node of the tree";

            rbtree_t rbtree3;
            rbtree3.insert(1, val);
            rbtree3.insert(2, val);
            rbtree3.insert(3, val);
            it = rbtree3.begin();
            rit = rbtree3.rbegin();

            EXPECT_EQ(1, it->first) << "Illegal leftmost node of the tree";
            EXPECT_EQ(3, rit->first) << "Illegal rightmost node of the tree";

            rbtree3.clear();
            EXPECT_EQ(rbtree3.begin(), rbtree3.end()) << "Iterator begin must be equal to end of empty tree";
            EXPECT_EQ(rbtree3.rbegin(), rbtree3.rend()) << "Iterator begin must be equal to end of empty tree";
        }
        // At this point everything dies that we created. Lets check the validity of object construction/destruction till now.
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, test_assignment)
    {
        {
            rbtree_t rbtreeA(rbTree);
            rbtree_t rbtreeB;
            rbtreeB = rbTree;

            rb_iterator it = rbTree.begin();
            rb_iterator itA = rbtreeA.begin();
            rb_iterator itB = rbtreeB.begin();

            bool result = true;

            while (it != rbTree.end())
            {
                if (it->first != itA->first || it->first != itB->first)
                {
                    result = false;
                }
                ++it;
                ++itA;
                ++itB;
            }
            
            EXPECT_EQ(rbtreeA.size(), rbtreeB.size()) << "Made from the same tree but different, why??";
            EXPECT_EQ(itA, it) << "All iterators should have reached the end together";
            EXPECT_EQ(itB, it) << "All iterators should have reached the end together";
            EXPECT_TRUE(result) << "Assignment didn't produce the same tree";
        }
        // At this point everything dies that we created. Lets check the validity of object construction/destruction till now.
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, test_swap)
    {
        {
            test_val_t val; // Default constructed!

            rbtree_t rbtreeA;
            rbtree_t rbtreeB;
        
            rbtreeA.insert(525, val);
            rbtreeA.insert(560, val);
            rbtreeA.insert(535, val);
            rbtreeA.insert(550, val);
            rbtreeA.insert(615, val);

            rbtreeA.swap(rbtreeB);

            EXPECT_EQ(5, rbtreeB.size()) << "rbtreeB should have had size of rbtreeA, i.e. 5";
            EXPECT_EQ(0, rbtreeA.size()) << "rbtreeA should have had size of rbtreeB, i.e. 0";

            EXPECT_EQ(rbtreeA.end(), rbtreeA.begin()) << "rbtreeA has some elements, swap fail!";
            EXPECT_NE(rbtreeB.end(), rbtreeB.begin()) << "rbtreeB has no elements, why?? swap fail!";

            swap(rbtreeB, rbtreeA);

            EXPECT_EQ(rbtreeB.end(), rbtreeB.begin()) << "rbtreeB has some elements, swap fail!";
            EXPECT_NE(rbtreeA.end(), rbtreeA.begin()) << "rbtreeA has no elements, why?? swap fail!";
        }
        // At this point everything dies that we created. Lets check the validity of object construction/destruction till now.
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, test_clear)
    {
        rbtree_t rbtreeA(rbTree);
        EXPECT_NE(0, rbtreeA.size()) << "Size must not be 0";

        rbtreeA.clear();
        EXPECT_EQ(0, rbtreeA.size()) << "Size must be 0 now";

        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

    TEST(RedBlackTree_Test, god_test)
    {
        rbtree_t rbtreeA;
        rbtree_t rbtreeC;
        {
            using namespace std;
            srand(static_cast<unsigned int>(time(NULL)));

            rbtree_t rbtreeB;
            test_val_t val; // Default constructed!
            vector<test_key_t> listInts;
            set<test_key_t> setInts;
     
            const size_t MAX = 100000;
            size_t i=0;
        
            listInts.reserve(MAX);

            while (i < MAX)
            {
                test_key_t key = rand();
                rbtreeB.insert(key, val);
                listInts.push_back(key);
                setInts.insert(key);
                ++i;
            }

            rbtreeC = rbtreeB; 
            rbtreeA = rbtreeB;
            rbtree_t rbtreeD(rbtreeB);

            for (i = 0; i < listInts.size(); ++i)
            {
                rbtreeB.erase(i);
            }

            set<test_key_t>::iterator setIt = setInts.begin();
            while (setIt != setInts.end())
            {
                rbtreeD.erase(*setIt);
                ++setIt;
            }
        }
        rbtreeA.clear();
        rbtreeC.clear();
        // At this point everything dies that we created. Lets check the validity of object construction/destruction till now.
        EXPECT_EQ(refStateInfo.m_copyConstructor_count + refStateInfo.m_constructor_count, refStateInfo.m_destructor_count) << "Constructor/Destructor calls mismatch, leak??";
    }

}
}   // namespace glare
